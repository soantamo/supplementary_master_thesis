---
title: "Supplementary Information Master Thesis"
author: "Sophie Moreau"
date: "2024-05-08"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
library(tidyverse)
library(here)
library(readr)
library(viridis)

```

#Introduction
This is the supplementary information of the Master thesis. This document
covers the whole analysis performed to assess response diversity between fish communities
in Swiss peri-alpine lakes. 
This document has two parts: Data preparation (1) and Data analysis (2). 
Function to model general additive models is provided separately (see function_GAM.R). 
Code for figures used in the method figure is also provided separately (see supplementary_method_figure.R) 

#1. Data preparation
##Abundance data
```{r}
##read in the data: Simstrat model data and Projet Lac combined
projet_lac_data <- read.csv("PLDB_final_short_depth_climate_cleantaxa_20052022.csv")

str(projet_lac_data)

# preparing additional column with abundance data of each species
abundance_data <- projet_lac_data |> 
  # exclude rows without taxa information
  filter(!Taxa_latin_FINAL %in% "NO_FISH") |> 
  # exclude samples obtained by electro-fishing
  filter(!Protocol %in% "electro") |> 
  #select columns relevant for species individual occurrences
 group_by(Lake, Basin3, Fishec_action, mean_temp_per_day, mean_last_7days, Weightg_raw, Weightg_soak, Depth_sample, Taxa_latin_FINAL, Protocol) |> 
  # prepare column with abundance of each species
  tally() |> 
  # values_fill = 0 added to make all NAs into 0
  pivot_wider(names_from = Taxa_latin_FINAL, values_from = n, values_fill = 0) 

# abundance of each species
abundance_data_long <- abundance_data |> 
  pivot_longer(cols = !(Lake : Protocol), names_to = "Species", values_to = "Abundance")

# add presence-absence column
abundance_data_long$Presence <- ifelse(abundance_data_long$Abundance >= 1, 1, 0)

# View(abundance_data_long)

max(abundance_data_long$Presence) #check if presence-absence only 0 and 1
max(abundance_data_long$Abundance)

#we only need information on species present in the lake, not all of them
abundance_data_long_lakepresence <- abundance_data_long |> 
  group_by(Lake, Species) |>
  # . stands for data being piped in do function
  do(LakePresence = max(.$Presence)) |> 
  unnest(cols = LakePresence)

# double-check 
abundance_data_long_lakepresence |>
  filter(LakePresence == "1") |> 
  group_by(Lake, LakePresence) |>
  count()

# join the two dfs
df_final <- abundance_data_long_lakepresence |> 
  filter(LakePresence == "1") |> 
  left_join(abundance_data_long )

#double-check if all lakepresence = 1
max(df_final$LakePresence)
min(df_final$LakePresence)

# save final df
saveRDS(df_final, "df_final.rds")

```

##Taxonomy and requirements
We pooled several species into ecomorphs to prevent loss of data-points. 
We also excluded species that were caught less than 10 times in the whole Projet Lac. 

```{r}
# read in prepared df
df_final <- readRDS("df_final.rds")

#######refining errors in species' identity that were noticed upon examination of the
# data frame, following the table 16 in the Projet Lac "Synthesis report"

# C. brienzii should not be present in lake Thun, add to Coregonus sp.

df_final <- df_final |>
  mutate(Species = ifelse(Species %in% c("Coregonus_brienzii") & Lake %in% c("Thun"),
                          "Coregonus_sp", as.character(Species)))

# Salvelinus umbla in Lake Thun should be Salvelinus sp. 

df_final <- df_final |>
  mutate(Species = ifelse(Species %in% c("Salvelinus_umbla") & Lake %in% c("Thun"),
                          "Salvelinus_sp", as.character(Species)))


# Squalius squalus in Biel and Neuchatel to Squalius cephalus

df_final <- df_final |>
  mutate(Species = ifelse(Species %in% c("Squalius_squalus") & Lake %in% c("Biel", 
                                                                           "Neuchatel"),
                          "Squalius_cephalus", as.character(Species)))


#######Pooling species to be able to include more samples
# Profundal Cottus gobio are pooled

df_final <- df_final |>
  mutate(Species = ifelse(Species %in% c(
    "Cottus_gobio_Profundal_Thun",
    "Cottus_gobio_Profundal_Lucerne", "Cottus_gobio_Profundal_Walen"
  ),
  "Cottus_sp_Profundal", as.character(Species)
  ))


# Salvelinus is pooled into "profundal" and "limnetic" habitats

# profundal

df_final <- df_final |>
  mutate(Species = ifelse(Species %in% c( "Salvelinus_sp_Profundal_dwarf_Thun", 
                                          "Salvelinus_sp_Profundal_dwarf_VWS", 
                                          "Salvelinus_sp_Profundal_extreme_Thun",
    "Salvelinus_sp_Profundal_Walen_I", "Salvelinus_sp_Profundal_Walen_II"),
  "Salvelinus_sp_Profundal", as.character(Species)
  ))


# limnetic 
df_final <- df_final |>
  mutate(Species = ifelse(Species %in% c("Salvelinus_sp_Limnetic_Thun", "Salvelinus_sp_Limnetic_VWS"),
                          "Salvelinus_sp_Limnetic", as.character(Species)))


# Coregonus species are pooled to new groups based on ecomorphs,
# following De-Dayne et al. 2022

# Albeli
df_final <- df_final |>
  mutate(Species = ifelse(Species %in% c("Coregonus_albellus", "Coregonus_candidus", "Coregonus_confusus",
                                         "Coregonus_heglingus", "Coregonus_zugensis"),
                          "Coregonus_sp_albeli", as.character(Species)))
# Balchen
df_final <- df_final |>
  mutate(Species = ifelse(Species %in% c("Coregonus_alpinus", "Coregonus_arenicolus", "Coregonus_duplex",
                        "Coregonus_helveticus", "Coregonus_palaea"),
                          "Coregonus_sp_balchen", as.character(Species)))

# Felchen

df_final <- df_final |>
  mutate(Species = ifelse(Species %in% c("Coregonus_brienzii", "Coregonus_fatioi", "Coregonus_intermundia",
                                         "Coregonus_litoralis", "Coregonus_macrophthalmus", "Coregonus_zuerichensis"),
                          "Coregonus_sp_felchen", as.character(Species)))
# Large pelagic

df_final <- df_final |>
  mutate(Species = ifelse(Species %in% c("Coregonus_acrinasus", "Coregonus_wartmanni"),
                          "Coregonus_sp_large_pelagic", as.character(Species)))

# Benthic profundal
df_final <- df_final |> 
  mutate(Species = ifelse(Species == "Coregonus_profundus",
                          "Coregonus_sp_benthic_profundal", as.character(Species)))
# Pelagic profundal
df_final <- df_final |> 
  mutate(Species = ifelse(Species == "Coregonus_nobilis",
                          "Coregonus_sp_pelagic_profundal", as.character(Species)))

# "Coregonus_sarnensis": could not be assigned to Albeli or Felchen

# check species list
species <- df_final |> 
  distinct(Species)

# check how many species have less than 10 overall observations: 30
df_final |> 
  group_by(Species) |> 
  summarize(tot_abu = sum(Presence)) |> 
  filter(tot_abu <= 10)

# exclusion of species with less than 10 overall observations
df_models <- df_final |> 
  group_by(Species) |> 
  mutate(tot_abu = sum(Presence)) |> 
  ungroup() |> 
  filter(tot_abu >= 10) 

# save the df of the refined species, df will be used for the models
saveRDS(df_models, "df_models.rds")

df_models$Species <- as.factor(df_models$Species)
levels(df_models$Species)

species <- df_models |> 
  group_by(Species) |> 
  summarize(tot_obs = sum(Abundance))

```
##Data frames for GAMs
We compiled four data frames for the four types of general additive models that 
were run: Species with 1) binomial dataoccurring in one lake,
2) abundance data occurring in one lake, 3) binomial data 
occuring in multiple lakes, 4) abundance data and occuring in multiple lakes. 

```{r}
###Overview
#1. Separation of species into binomial and abundance data: sample with abundance > 1, 0 and 1 only -> binomial data
#2. species that occur only in one lake: Lake not added as random effect

#1. binomial vs. abundance data

df_models$Species <- as.character(df_models$Species)

non_binomial_species <- df_models |> 
  filter(Abundance > 1) |> 
  group_by(Species) |>
  distinct(Species) |> 
  pull(Species)


binomial_species <- df_models |> 
  filter(!Species %in% non_binomial_species) |> 
  distinct(Species) |> 
  pull(Species)


#2. binomial vs. abundance species occuring only in one lake

#1: GAM without lake as random effect, binomial

bi_one_occurence <- df_models |> 
  filter(Species %in% binomial_species) |>
  group_by(Species) |>
  summarize(n_lake = n_distinct(Lake)) |> 
  filter(n_lake == 1) |>
  pull(Species)

# save df
df_bi <- df_models |>
  filter(Species %in% bi_one_occurence)

saveRDS(df_bi, "data_frame_models/df_binomial_gam")

#2 GAM abundance without lake as random effect
abu_one_occurence <- df_models |> 
  filter(Species %in% non_binomial_species) |> 
  group_by(Species) |> 
  summarize(n_lake = n_distinct(Lake)) |> 
  filter(n_lake == 1) |>
  pull(Species)


df_abu <- df_models |> 
  filter(Species %in% abu_one_occurence)

saveRDS(df_abu, "data_frame_models/df_abundance_gam")

#binomial vs. abundance species occuring in several lakes

#3 gam with random intercept, binomial
bi_multi_occurence <- df_models |> 
  filter(Species %in% binomial_species) |> 
  group_by(Species) |> 
  summarize(Lakes = n_distinct(Lake)) |> 
  filter(!Lakes == 1) |> 
  pull(Species)

df_binomial_re <- df_models |> 
  filter(Species %in% bi_multi_occurence)

saveRDS(df_binomial_re, "data_frame_models/df_binomial_re")

#4 abundance GAM with random intercept
abu_multi_occurence <- df_models |> 
  filter(Species %in% non_binomial_species) |> 
  group_by(Species) |> 
  summarize(Lakes = n_distinct(Lake)) |> 
  filter(!Lakes == 1) |> 
  pull(Species)

df_abundance_re <- df_models |> 
  filter(Species %in% abu_multi_occurence)

saveRDS(df_abundance_re, "data_frame_models/df_abundance_re")

```

#2. Data Analysis
##General Additive Models
Running the predictions for all GAMs with the smaller data frames to reduce running 
time. 

```{r}
# packages relevant for data analysis
library(tidyverse)
library(here)
library(readr)
library(readxl)
library(gratia)
library(mgcv)
library(forcats)
library(ggpubr)
library(RColorBrewer)
library(broom)
library(grid)
library(DHARMa)
library(mgcViz)
library(gridExtra)
library(grid)
# function for the GAMs
source(here("function_GAM.R"))
```

###Predictions of GAMs

```{r}
# read in the dataframes
df_1 <- readRDS("data_frame_models/df_binomial_gam")
df_2 <- readRDS("data_frame_models/df_abundance_gam")
df_3 <- readRDS("data_frame_models/df_binomial_re")
df_4 <- readRDS("data_frame_models/df_abundance_re")

# use own function predictions() from function_GAM.R to predict species' models
# across all lakes

# predictions take VERY LONG! and two folders are needed to store the 
# DHARMa and prediction output inside: 
# total_models/gam_check
# total_models/predictions

#df1 and df2 are the fastest ones
# predictions() can also be used directly with df_models -> takes longer

predictions(df_1) 
predictions(df_2)
predictions(df_3)
predictions(df_4)

#  compile data frame with all predictions from the saved species' model predictions

df_predictions_all <- list.files(path = "total_models/predictions", pattern = ".rds", full.names = TRUE) |>
  map_dfr(readRDS)

# save total predictions as RDS
saveRDS(df_predictions_all, "total_models/df_pred_all.rds")

```

####Fig. 2
Overview of all model predictions

```{r, fig.show='hide'}
# Load total predictions
model_predictions <- readRDS("total_models/df_pred_all.rds")

# check the species list
model_predictions$species <- as.factor(model_predictions$species)
levels(model_predictions$species)

# Plot Figure 2. 
all_predictions <- model_predictions |>
  # exclude Lepomis gibbosus
  filter(species != "Lepomis_gibbosus") |> #lepomis gibbosus was excluded upon examination
  ggplot(aes(temp, fit)) +
  geom_ribbon(aes(ymin = (fit - se.fit), ymax = (fit + se.fit), fill = factor(species)), alpha = 0.3) +
  geom_line(aes(color = factor(species))) +
  theme_bw() +
  facet_wrap(~species, scale = "free_y", labeller = labeller(species = label_wrap_gen(width = 10))) +
  theme(strip.background = element_rect(fill = "lightgrey"), strip.text = element_text(size = 6)) +
  scale_color_viridis(discrete = TRUE, guide = NULL, option = "G", aesthetics = c("color", "fill")) +
  xlab("Temperature") +
  ylab("Abundance")


all_predictions

# save the plot as TIFF
# tiff(paste("total_models/plots/all_predictions_models.tiff", sep = ""), units="in", width = 12, height=8, res=300)
# plot(all_predictions)
# 
# # Closing the graphical device
# dev.off()

```

##Sensitivity testing
Testing if depth-driven temperature models can adequately fit abundance data compared to
a temperature and depth model. 
Models were compared in the eleven most abundant species. 

```{r}
# Read in abundance and depth data of all species included for modelling
df_models <- readRDS("df_models.rds")

# find 11 most abundant  species
species_list <- df_models |> 
  filter(tot_abu > 300) |> 
  distinct(Species) |> 
  pull(Species)

# most abundant species
 # "Alburnus_alburnus", "Coregonus_sp_albeli", "Coregonus_sp","Gasterosteus_aculeatus",
 # "Gobio_gobio", "Leuciscus_leuciscus", "Perca_fluviatilis", "Rutilus_rutilus", 
 # "Sander_lucioperca", "Scardinius_erythrophthalmus","Gymnocephalus_cernua"

# filter df into the most abundant species and select the columns of interest

df_sensitivity <- df_models |> 
  filter(tot_abu > 300) |> 
  select(Lake, Species, Protocol, Depth_sample, Abundance, Presence, mean_last_7days) |> 
  #there are some NAs in depth -> drop them
  drop_na(Depth_sample, mean_last_7days)

df_sensitivity$fLake <- as.factor(df_sensitivity$Lake)
df_sensitivity$fProtocol <- as.factor(df_sensitivity$Protocol)

# Loop through the eleven species and fit temp and temp-depth model

species_list <- df_sensitivity |> 
  distinct(Species) |> 
  pull(Species)

# loop through the species, model both GAMs, check DHARMa and predictions
for (i in species_list){
  
  data <- df_sensitivity |> 
    filter(Species == i)
  
  #Model fit for temp and depth
  model1 <- gam(data = data, Abundance ~ s(mean_last_7days, k = 3) + s(Depth_sample, k = 3)
                + s(fLake, bs = 're')
                +  s(fProtocol, bs = 're'), family = ziP())
  # Model fit for temp
  model2 <- gam(data = data, Abundance ~ s(mean_last_7days, k = 3)
                + s(fLake, bs = 're')
                +  s(fProtocol, bs = 're'), family = ziP())
  # validate model predictions for temp and depth model with dharma:
  # prepare residuals
  simulationOutput <- simulateResiduals(fittedModel = model1, plot = F)
  # tiff_filename <- paste("total_models/gam_check/temp_depth_check_", i, ".tiff", sep = "")
  # tiff(tiff_filename, width = 800, height = 600)
  print(plot(simulationOutput))
  # dev.off()
  # Plotting standardized residuals against predictors
  # tiff_file_2 <- paste("total_models/gam_check/temp_depth_predictor_", i, ".tiff", sep = "")
  # tiff(tiff_file_2, width = 800, height = 600)
  print(plotResiduals(model1, data$mean_last_7days, xlab = "temp", main=NULL))
  # dev.off()
  
  
  # for predictions with random effects in the GAMs, we select a random value
  # of the level of random effects and exclude the random effects in the prediction
        
  # lakes where the species is present
  unique_lakes <- distinct(data, Lake) |>
    pull()
  
  # select random lake for prediction
  random_lake <- sample(unique_lakes, 1)
  
  # for temp-depth model only predict for depth where the species is present
  presence_depth <- data |> 
    filter(Presence == 1) |>
    distinct(Depth_sample) |> 
    pull(Depth_sample)
  
  # take randomly 5 depth values for prediction
  random_depth <- sort(sample(presence_depth, 5))
  
  # Convert sorted values to factors with original order
  factor_random_depth <- factor(random_depth, levels = random_depth, ordered = TRUE)
  
  # grid for each of the models
  
  # temp-depth model predicted with random depths where the species is present
 grid1 <- expand.grid(mean_last_7days = seq(
    from = min(data$mean_last_7days, na.rm = TRUE),
    to = max(data$mean_last_7days, na.rm = TRUE), length = 200),
    fProtocol = factor("VERT"), fLake = factor(random_lake), 
    Depth_sample = factor_random_depth)
  
  grid2 <- expand.grid(mean_last_7days = seq(
    from = min(data$mean_last_7days, na.rm = TRUE),
    to = max(data$mean_last_7days, na.rm = TRUE), length = 1000),
    fProtocol = factor("VERT"), fLake = factor(random_lake))
  
  # print relevant stats
  print(paste(i))
  print(glance(model1))
  print(glance(model2))
  

  # manually predict both models
  model_prediction1 <- predict.gam(model1, newdata = grid1,
                                  exclude = c("s(fProtocol)", "s(fLake)"), #exclude the re
                                  term = "s(mean_last_7days)", type = "response",             
                                  se.fit = TRUE)

  model_bind1 <- cbind(grid1, as.data.frame(model_prediction1)) |>
    mutate(model = factor("temp_and_depth"))

# predict model2
  model_prediction2 <- predict.gam(model2, newdata = grid2,
                                   exclude = c("s(fProtocol)", "s(fLake)"),
                                   type = "response", se.fit = TRUE)

  model_bind2 <- cbind(grid2, as.data.frame(model_prediction2)) |>
    mutate(model = factor("temp"))


  df_pred <- bind_rows(model_bind1, model_bind2) |>
    rename(temp = mean_last_7days) |>
    select(-fProtocol, -fLake) |>
    mutate(Depth_sample = factor(ifelse(is.na(Depth_sample), "temp", as.character(Depth_sample))))


  # Extract numeric depth levels
  numeric_levels <- levels(df_pred$Depth_sample)[!levels(df_pred$Depth_sample) %in% "temp"]

  # Sort numeric depth levels
  sorted_numeric_levels <- sort(as.numeric(numeric_levels))

  # Combine sorted numeric levels with "temp" level
  sorted_levels <- c(as.character(sorted_numeric_levels), "temp")

  # Reorder levels
  df_pred$Depth_sample <- factor(df_pred$Depth_sample, levels = sorted_levels)

  # Check the levels to confirm they are ordered from lowest to highest
  levels(df_pred$Depth_sample)
  
  # rescale predictions of both models
  df_pred_rescaled <- df_pred |>
    group_by(model) |>
    mutate(fit_rescaled = (fit - min(fit)) / (max(fit) - min(fit))) |>
    mutate(se_fit_rescaled = (se.fit - min(se.fit)) / (max(se.fit) - min(se.fit))) |> 
    mutate(species = factor(i))
  
  # save predictions of both models in a rds
   saveRDS(df_pred_rescaled, paste0("total_models/sensitivity/rds/sensitivity_predictions_", i, ".rds"))
  

}

# prepare total predictions of all models
sensitivity_predictions <- list.files(path = "total_models/sensitivity/rds", pattern = ".rds", full.names = TRUE) |>
  map_dfr(readRDS)

# save total predictions as RDS
saveRDS(sensitivity_predictions, "total_models/sensitivity_predictions.rds")


```

###Fig. S1

```{r}
# read in the sensitivity testing data
sensitivity_predictions <- readRDS("total_models/sensitivity_predictions.rds")

levels(sensitivity_predictions$species)

# Plot both model predictions together per species
 figure_s1 <- sensitivity_predictions |>
    ggplot(aes(temp, fit_rescaled, color = model, fill = model)) +
    geom_line() +
    geom_ribbon(aes(ymin = (fit_rescaled - se.fit), ymax = (fit_rescaled + se.fit)), color = NA, alpha = 0.1) +
    theme_bw() +
    # labs(title = paste("Sensitivity Test", i)) +
    scale_color_manual(values = c("#08306B", "#D73027"), aesthetics = c("color", "fill")) +
    facet_wrap(~species, scale = "free") +
    ylab("Abundance") +
    xlab("Temperature") +
   theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        legend.position = "right",
        legend.title = element_blank()) 
 
  figure_s1
  # save as TIFF
# tiff(paste("total_models/plots/sensitivity_overview.tiff", sep = ""), units="in", width=11, height=7, res=300)
# 
# plot(figure_s1)
# 
# dev.off()

```
##Derivatives calculation 

We calculated derivatives for each species per lake.

```{r}

# Derivatives() will ignore any random effect smooths it encounters in object.

# Table of pecies that were recorded with electro, fishbase or eawag, following Table 16 in Projet Lac Synthesis Report. 
# Plus the minimum and maximum temp in each lake -> needed for the new data for 
# calculating derivatives

species_lake <- read_xlsx("species_occurrences_lakes.xlsx") 
str(species_lake)

species_lake$fLake <- as.factor(species_lake$Lake)
species_lake$fProtocol <- as.factor(species_lake$Protocol)
species_lake$Species <- as.factor(species_lake$Species)


#Loading all four dfs to calculate derivatives

df_binomial_gam <- readRDS("data_frame_models/df_binomial_gam")
df_binomial_gam$fLake <- as.factor(df_binomial_gam$Lake)
df_binomial_gam$fProtocol <- as.factor(df_binomial_gam$Protocol)

df_abundance_gam <- readRDS("data_frame_models/df_abundance_gam")
df_abundance_gam$fProtocol <- as.factor(df_abundance_gam$Protocol)
df_abundance_gam$fLake <- as.factor(df_abundance_gam$Lake)

df_binomial_re <- readRDS("data_frame_models/df_binomial_re")
df_binomial_re$fLake <- as.factor(df_binomial_re$Lake)
df_binomial_re$fProtocol <- as.factor(df_binomial_re$Protocol)

df_abundance_re <- readRDS("data_frame_models/df_abundance_re")
df_abundance_re$fLake <- as.factor(df_abundance_re$Lake)
df_abundance_re$fProtocol <- as.factor(df_abundance_re$Protocol)

# Now four different loops are run to calculate derivatives of each species 
# in each lake

# Model 1: Binomial data without random intercepts

species_list <- df_binomial_gam |>
  distinct(Species) |>
  pull(Species)

species_list <- sort(species_list)

derivatives <- list()
gam_output <- list()
model_prediction <- list()

# loop through the list of species
for (i in species_list) {
  data <- df_binomial_gam |>
    filter(Species == i)

  lake_data <- species_lake |>
    filter(Species == i)

  gam_output[[i]] <- gam(data = data, Abundance ~ s(mean_last_7days, k = 3) + s(fProtocol, bs = 're'), family = binomial)

  lake_list <- distinct(lake_data, Lake) |>
    pull()

  # loop through all lakes where the species is present, lake list is based on the information from
  # Projet Lac
  for (j in lake_list){

    data_lake <- species_lake |>
      filter(Species == i) |>
      filter(Lake == j)
    
    # using minimum and maximum temp in the lake for derivatives
     newdata <- tibble(mean_last_7days = seq(from = min(data_lake$temp, na.rm = TRUE),
                                             to = max(data_lake$temp, na.rm = TRUE), length = 200),
                       fProtocol = factor("VERT"))
     
     # calculate derivatives
     derivatives <- derivatives(gam_output[[i]], data = newdata) |>
       mutate(fLake = factor(j)) |>
       mutate(species = factor(i)) |>
       rename(temp = data)
     
     saveRDS(derivatives, paste0("total_models/derivatives/derivatives_", i, "_",  j, ".rds"))
  }
}


# Model 2.1: Abundance data and no random intercept for lake -> but binomial
# Coregonus_sp_benthic_profundal did not run with ZIP and was thus
# run with binomial. 

species_list <- df_abundance_gam |> 
  # binomial one
  filter(Species == "Coregonus_sp_benthic_profundal") |>
  distinct(Species) |> 
  pull(Species)

species_list <- sort(species_list)

derivatives <- list()
gam_output <- list()
model_prediction <- list()

for (i in species_list) {
  
  data <- df_abundance_gam |> 
    filter(Species == i)
  
  # binomial family instead of ZIP
  gam_output[[i]] <- gam(data = data, Presence ~ s(mean_last_7days, k = 3) +
                           s(fProtocol, bs = 're'), family = binomial())
  
  lake_data <- species_lake |>
    filter(Species == i)
  
  lake_list <- distinct(lake_data, Lake) |>
    pull()
  
  for (j in lake_list){
    
    data_lake <- species_lake |>
      filter(Species == i) |>
      filter(Lake == j)
    
    newdata <- tibble(mean_last_7days = seq(
      from = min(data_lake$temp, na.rm = TRUE),
      to = max(data_lake$temp, na.rm = TRUE), length = 200),
      fProtocol = factor("VERT"))

    derivatives <- derivatives(gam_output[[i]], data = newdata) |>
      mutate(fLake = factor(j)) |>
      mutate(species = factor(i)) |>
      rename(temp = data)
    
    saveRDS(derivatives, paste0("total_models/derivatives/derivatives_", i, "_",  j, ".rds"))
  }
}


# Model 2.2: Abundance data and no random intercept for lake -> ZIP
# all other species in this group run with ZIP

species_list <- df_abundance_gam |>
  filter(!Species == "Coregonus_sp_benthic_profundal") |>
  distinct(Species) |> 
  pull(Species)

species_list <- sort(species_list)

derivatives <- list()
gam_output <- list()
model_prediction <- list()


for (i in species_list) {
  
  data <- df_abundance_gam |> 
    filter(Species == i)
  
  gam_output[[i]] <- gam(data = data, Abundance ~ s(mean_last_7days, k = 3) + s(fProtocol, bs = 're'),
                         family = ziP())
  
  lake_data <- species_lake |>
    filter(Species == i)
  
  lake_list <- distinct(lake_data, Lake) |>
    pull()
  
  for (j in lake_list){
    
    data_lake <- species_lake |>
      filter(Species == i) |>
      filter(Lake == j)
    
    newdata <- tibble(mean_last_7days = seq(
      from = min(data_lake$temp, na.rm = TRUE),
      to = max(data_lake$temp, na.rm = TRUE), length = 200),
      fProtocol = factor("VERT"))
    
    derivatives <- derivatives(gam_output[[i]], data = newdata) |>
      mutate(fLake = factor(j)) |>
      mutate(species = factor(i)) |>
      rename(temp = data)
    
    saveRDS(derivatives, paste0("total_models/derivatives/derivatives_", i, "_",  j, ".rds"))
  }
}

# Model 3: Binomial data and random intercept for lake 

species_list <- df_binomial_re |> 
  distinct(Species) |> 
  pull(Species)

species_list <- sort(species_list)

derivatives <- list()
gam_output <- list()
model_prediction <- list()

for (i in species_list) {
  
  data <- df_binomial_re |> 
    filter(Species == i)
  
  gam_output[[i]] <- gam(data = data, Abundance ~ s(mean_last_7days, k = 3) + s(fLake, bs = "re")
                         + s(fProtocol, bs = 're'), family = binomial)
  
  lake_data <- species_lake |>
    filter(Species == i)
  
  lake_list <- distinct(lake_data, Lake) |>
    pull()
  
  unique_lakes <- distinct(data, Lake) |> 
    pull()

  
  for (j in lake_list){
    
    data_lake <- species_lake |>
      filter(Species == i) |>
      filter(Lake == j)
    
    # take all lakes where the species is present and take random one for 
    # the data included in derivatives()
    random_lake <- sample(unique_lakes, 1)
  
    newdata <- tibble(mean_last_7days = seq(
      from = min(data_lake$temp, na.rm = TRUE),
      to = max(data_lake$temp, na.rm = TRUE), lenqh = 200),
      fProtocol = factor("VERT"), fLake = factor(random_lake))
    
    derivatives <- derivatives(gam_output[[i]], data = newdata) |>
      mutate(fLake = factor(j)) |>
      mutate(species = factor(i)) |>
      rename(temp = data)
    
    saveRDS(derivatives, paste0("total_models/derivatives/derivatives_", i, "_",  j, ".rds"))
 
  }
}

# Model 4.1: Abundance data and random intercept for lake, simplified models
# multiple species in this group were simplified and run with binomial

species_list <- df_abundance_re |>
  # simplified models
  filter(Species %in% c("Alburnus_arborella", "Barbatula_sp_Lineage_I",
                                "Cyprinus_carpio", "Phoxinus_csikii", "Salmo_trutta",
                        "Lepomis_gibbosus")) |>
  distinct(Species) |>
  pull(Species)

species_list <- sort(species_list)


derivatives <- list()
gam_output <- list()
model_prediction <- list()


for (i in species_list) {

  data <- df_abundance_re |>
    filter(Species == i)

  gam_output[[i]] <- gam(data = data, Presence ~ s(mean_last_7days, k = 3) + s(fLake, bs = 're')
                         +  s(fProtocol, bs = 're'), family = binomial)

  lake_data <- species_lake |>
    filter(Species == i)

  lake_list <- distinct(lake_data, Lake) |>
    pull()

  unique_lakes <- distinct(data, Lake) |>
    pull()

  for (j in lake_list){

    data_lake <- species_lake |>
      filter(Species == i) |>
      filter(Lake == j)

    random_lake <- sample(unique_lakes, 1)
    
    newdata <- tibble(mean_last_7days = seq(
      from = min(data_lake$temp, na.rm = TRUE),
      to = max(data_lake$temp, na.rm = TRUE), length = 200),
      fLake = factor(random_lake), fProtocol = factor("VERT"))
    
    derivatives <- derivatives(gam_output[[i]], data = newdata) |>
      mutate(fLake = factor(j)) |>
      mutate(species = factor(i)) |>
      rename(temp = data)
    saveRDS(derivatives, paste0("total_models/derivatives/derivatives_", i, "_",  j, ".rds"))

  }
}

# Model 4.1: Abundance data and random intercept for lake, complex models

species_list <- df_abundance_re |> 
  # exclusion of simplified models
  filter(!Species %in% c("Alburnus_arborella", "Barbatula_sp_Lineage_I",
                        "Cyprinus_carpio", "Phoxinus_csikii", "Salmo_trutta", 
                        "Lepomis_gibbosus")) |>
  distinct(Species) |> 
  pull(Species)

species_list <- sort(species_list)

derivatives <- list()
gam_output <- list()
model_prediction <- list()


for (i in species_list) {
  
  data <- df_abundance_re |> 
    filter(Species == i)
  
  gam_output[[i]] <- gam(data = data, Abundance ~ s(mean_last_7days, k = 3) + s(fLake, bs = 're')
                         +  s(fProtocol, bs = 're'), family = ziP())
  
  lake_data <- species_lake |>
    filter(Species == i)
  
  lake_list <- distinct(lake_data, Lake) |>
    pull()
  
  unique_lakes <- distinct(data, Lake) |> 
    pull()
  
  for (j in lake_list){
    
    data_lake <- species_lake |>
      filter(Species == i) |>
      filter(Lake == j)
   
    random_lake <- sample(unique_lakes, 1)

    newdata <- tibble(mean_last_7days = seq(
      from = min(data_lake$temp, na.rm = TRUE),
      to = max(data_lake$temp, na.rm = TRUE), length = 200),
      fLake = factor(random_lake), fProtocol = factor("VERT"))
    
    derivatives <- derivatives(gam_output[[i]], data = newdata) |>
      mutate(fLake = factor(j)) |>
      mutate(species = factor(i)) |>
      rename(temp = data)
    
    saveRDS(derivatives, paste0("total_models/derivatives/derivatives_", i, "_",  j, ".rds"))

  }
}

# save all the derivatives in one file

df_deriv <- list.files(path = "total_models/derivatives", pattern = ".rds", full.names = TRUE) |> 
  map_dfr(readRDS)

saveRDS(df_deriv, "total_models/df_deriv_all.rds")

# save total derivatives as RDS (no exclusions)
# saveRDS(df_deriv, "total_models/df_deriv_all_no_excl.rds")

```

###Fig. S2 
Overview of derivatives in each lake community

```{r}
# Read in derivative data
all_models_derivatives <- readRDS("total_models/df_deriv_all.rds")
all_derivatives <- as_tibble(all_models_derivatives)

str(all_derivatives)

# Highlighting species with interesting derivatives: 
species_group <- all_derivatives |> 
  filter(species %in% c("Phoxinus_csikii", "Barbatula_sp_Lineage_II", "Cottus_sp_Po_profundal")) |> 
  distinct(species) |> 
  pull(species)

# Plot S2: derivatives included in each lake community
overview_derivatives <- all_derivatives |>
  arrange(fLake) |> 
  ggplot(aes(temp, derivative, color = species)) +
  geom_line() +
  facet_wrap(~fLake) +
  theme_bw(base_size = 16) +
  scale_color_viridis(discrete = TRUE, breaks = species_group, option = "G") +
  xlab("Temperature") +
  ylab("Derivatives") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        legend.position = "right",
        legend.title = element_blank()) +
  geom_hline(yintercept = 0, color = "#7A7A7A")
 
  
overview_derivatives

# save as TIFF
# tiff(paste("total_models/plots/overview_derivatives_lake.tiff", sep = ""), units="in", width=11, height=7, res=300)
# 
# plot(overview_derivatives)
# 
# dev.off()
```

###Fig. S3

```{r}
# Data of the derivatives before simplifying multiple models
# without changes the 5 species were not run with simplified models. 
all_models_derivatives_no_excl <- readRDS("total_models/df_deriv_all_no_excl.rds")
df_deriv_no_excl <- as_tibble(all_models_derivatives_no_excl)

# Plot Figure S3a
#calculating maximum and mean derivatives for each species per lake

df_quantiles <- df_deriv_no_excl |> 
  group_by(species, fLake) |> 
  mutate(max_derivative = max(derivative)) |> 
  mutate(mean_derivative = mean(derivative)) |> 
  ungroup()

# calculate quantiles of derivatives
transform(quantile(df_quantiles$derivative,
                   c(0,0.01,0.05,0.1,0.25,0.5,0.75,0.85,0.9,0.95,0.99,1)))


# add column with the category of quantile each derivative is in
df_quantiles$groups <- cut(df_quantiles$derivative,              
                     breaks = c(-1.579943e+06, -2.342866e+00, -8.822087e-01,
                                -4.543748e-01, 3.454218e-04, 2.485142e-01,
                                5.527792e-01, 2.911987e+00, 2.018455e+01, 1.280898e+02,
                                1.231212e+07, 1.406101e+07),
                     labels = c("0-1%", "1-5%", "5-10%", "10-25%", "25-50%", "50-75%", "75-85%", "85-90%", "90-95%",
                                "95-99%", "99-100%"))

# Plot S3a: histogram of species' mean derivatives per lake
plot_percentiles <- df_quantiles |> 
  # Salmo trutta derivative is too large to be plotted
  filter(species != "Salmo_trutta") |> 
  ggplot(aes(x = mean_derivative, fill = factor(species))) + 
  geom_histogram(aes(y = after_stat(count / sum(count))), binwidth = 1.5) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_manual(values = c("Cyprinus_carpio" = "#80CDC1",
                                "Alburnus_arborella" = "#8C510A",
                                "Barbatula_sp_Lineage_I"="#DFC27D",
                               "Phoxinus_csikii" = "#01665E", "Salmo_trutta" = "#F46D43"))

plot_percentiles

# Plot S3a add lines for the percentiles
plot_percentiles_1 <- plot_percentiles +
  geom_vline(xintercept = 19.9, color = "red") +
  annotate("text", x= 18, y = 0.12, label="90th percentile", angle=90) +
  geom_vline(xintercept = 2.911987e+00, color = "red") +
  annotate("text", x= 1.5, y = 0.12, label="85th percentile", angle=90) +
  theme_classic(base_size = 13) +
  xlab("Mean species derivative per lake") +
  ylab("Percentage") +
 guides(fill = guide_legend(
    title = "Species")) +
  ylim(0, 0.2)
  
plot_percentiles_1

# save as TIFF
# tiff(paste("total_models/plots/plot_deriv_percentiles_1.tiff", sep = ""), units="in", width=12, height=6, res=300)
# 
# plot(plot_percentiles_1)
# 
# dev.off()

# above 90% = 2.018455e+01
df_quantiles |> 
  filter(derivative > 2.018455e+01) |> 
  distinct(species)

# 5 species above 90% -> those will be simplified to binomial 
# 1 Alburnus_arborella    
# 2 Barbatula_sp_Lineage_I
# 3 Cyprinus_carpio       
# 4 Phoxinus_csikii       
# 5 Salmo_trutta 


# Plotting Figure S3b

# just keeping mean and maximum derivative values for each lake and species
data_quantiles <- df_quantiles |> 
  distinct(mean_derivative, max_derivative, fLake, species)

# Breaking mean derivatives in the same percentiles as before
data_quantiles$percentiles <- cut(data_quantiles$mean_derivative,              
                     breaks = c(-1.579943e+06, -2.342866e+00, -8.822087e-01,
                                -4.543748e-01, 3.454218e-04, 2.485142e-01,
                                5.527792e-01, 2.911987e+00, 2.018455e+01, 1.280898e+02,
                                1.231212e+07, 1.406101e+07),
                     labels = c("0-1%", "1-5%", "5-10%", "10-25%", "25-50%", "50-75%", "75-85%", "85-90%", "90-95%",
                                "95-99%", "99-100%"))

# Plot S3b tile plot of mean derivatives per species in each lake
mean_deriv_plot <- data_quantiles |> 
  ggplot(aes(fLake, y = fct_reorder(species, mean_derivative), fill= percentiles)) + 
  geom_tile() +
  scale_fill_manual(breaks = levels(data_quantiles$percentiles),
                    values = rev(brewer.pal(11, "BrBG")))


derivative_percentiles_2 <- mean_deriv_plot +
  guides(fill = guide_legend(title = "percentiles (mean derivative)", reverse = TRUE)) +
  xlab("") +
  ylab("") +
  theme_classic(base_size = 16)

derivative_percentiles_2

# save plot as TIFF
tiff(paste("total_models/plots/plot_deriv_percentiles_2.tiff", sep = ""), units="in", width=19, height=12, res=300)

plot(derivative_percentiles_2)

dev.off()

```

##Calculating thermal response diversity

```{r}
# Function provided by Ross et al. "How to measure response diversity" used to calculate
# response diversity 

# read in function
source(here("functions.R"))

# load derivatives data
all_models_derivatives <- readRDS("total_models/df_deriv_all.rds")

all_deriv <- as_tibble(all_models_derivatives)

str(all_deriv)

levels(all_deriv$species)

#Calculating response diversity for each lake community

# Lepomis is excluded from the analysis
all_deriv <- all_deriv |>
  filter(!species %in% c("Lepomis_gibbosus"))

all_deriv$fLake <- as.character(all_deriv $fLake)

lakes_list <- all_deriv |> 
  distinct(fLake) |> 
  pull(fLake)

str(lakes_list)

lakes_list <- sort(lakes_list)

species_overview <- tibble()


all_deriv$species <- as.character(all_deriv$species)
all_deriv$species <- as.factor(all_deriv$species)

str(all_deriv )

# Loop to get response diversity measures for each lake 
# loop through list of lakes and calculate response diversity in the lake communities
for (i in lakes_list){
  
  data <- all_deriv |>
    select(temp, fLake, derivative, species) |> 
    filter(fLake == i)
 
  df_resp_div <- data |>
    pivot_wider(
      names_from = species,
      values_from = derivative)
  
  # apply the function from Ross et al. 
  # Dissimilarity
  df_resp_div$rdiv <- apply(df_resp_div[,-(1:2), drop = FALSE], 1, resp_div, sign_sens = F)
  # Divergence
  df_resp_div$sign <- apply(df_resp_div[,-(1:2), drop = FALSE], 1, resp_div, sign_sens = T)
  # Median Dissimilarity
  df_resp_div$Med <- median(df_resp_div$rdiv)
  
  # save response diversity metrics per lake
  saveRDS(df_resp_div, paste0("total_models/lakes_all_models/df_resp_div_", i, ".rds"))
  
}

# save the response diversity per lake into one file
resp_div_no_excl <- list.files(path = "total_models/lakes_all_models", pattern = ".rds", full.names = TRUE) |>
  map_dfr(readRDS) |>
  relocate(rdiv, Med, sign, .after = temp)

saveRDS(resp_div_no_excl,"total_models/resp_div_all.rds")
```

##Drivers of thermal response diversity

Preparing a df with the information on past eutrophication, species richness, and species categorization in each lake.
```{r}
# Df with properties of lakes
lake_info <- read_xlsx("lake_info.xlsx")

# select the columns we use
lake_selection <- lake_info |> 
  select(Lake, Phos_max, Max_depth, Lake_area)

# information about categorization in each lake for the subgroups
species_endemism <- read_excel("species_category_per_lake.xlsx") |> 
  rename(endemism = detail_category)

# exclude lepomis gibbosus and re-calculate species richness per lake
species_endemism_short <- species_endemism |> 
  filter(species != "Lepomis_gibbosus") |> 
  select(-sum_species) |> 
  group_by(fLake) |> 
  mutate(sum_species = sum(num_species))

species_endemism_short$endemism <- as.factor(species_endemism_short$endemism)

str(species_endemism_short)

# adding column with number of species per category in each lake
df_species_endemism <- species_endemism_short |> 
  select(-species, - num_species) |> 
  add_count(fLake, endemism) |> 
  rename(count = n) |> 
  distinct(fLake, count, sum_species, endemism)

str(df_species_endemism)

df_species_endemism$count <- as.numeric(df_species_endemism$count)

# making it wide 
df_species_endemism_long <- df_species_endemism |> 
  pivot_wider(names_from = endemism, values_from = count) |> 
  mutate_if(is.numeric, ~replace(., is.na(.), 0)) |> 
  rename(Lake = fLake)

str(df_species_endemism_long)

# merge endemism info and lake info 

endemism_lake <- merge(df_species_endemism_long, lake_selection)

# Read in data on response diversity metrics in each lake
resp_div_all <- readRDS("total_models/resp_div_all.rds") |> 
  select(temp:fLake)

# select response diversity columns we need
rdiv <- resp_div_all |>  
  select(temp, fLake, rdiv, sign) |>
  drop_na()

# calculate mean and maximum values and rename Lake
df_rdiv <- rdiv |> 
  group_by(fLake) |> 
  mutate(mean_rdiv = mean(rdiv)) |> 
  mutate(max_rdiv = max(rdiv)) |> 
  mutate(mean_sign = mean(sign)) |> 
  mutate(max_sign = max(sign)) |> 
  distinct(fLake, mean_rdiv, max_rdiv, mean_sign, max_sign) |> 
  rename(Lake = fLake)

# combine lake properties, species subgroups and response diversity 

df_lm <- merge(df_rdiv, endemism_lake)

str(df_lm)

# phosphorus values as numeric
df_lm$Phos_max <- as.numeric(df_lm$Phos_max)

```

###Species richness and eutrophication
Multiple linear regression to calculate the effect of species richness and
eutrophication on response diversity.

###Fig. 3

```{r}
# Multiple linear regression for mean dissimilarity explained by species richness and past eutrophication: 
# lm(mean_rdiv  ~ species richness + eutrophication)
# Predict manually with new data eutrophication value fixed at mean and species richness min() to max()
# do the same the other way around: mean_rdiv  ~  eutrophication + species richness, with species richness fixed at mean and eutrophication min() to max()species richness +
#   prepare these two plots

# Phosphorus data on Poschiavo is not available
df_lm_excl <- df_lm |> 
  filter(Lake != "Poschiavo")


# first lm for species richness ~ maximum phosphorus 

lm1 <- lm(mean_rdiv ~ sum_species + Phos_max, data = df_lm_excl)

# checking model assumptions
summary(lm1)
shapiro.test(resid(lm1))
lmtest::bptest(lm1)
plot(lm1)

# model assumptions validated

# manually predict data
new_data <- tibble(sum_species = seq(from = min(df_lm_excl$sum_species), to = max(df_lm_excl$sum_species), length = 50), Phos_max = mean(df_lm_excl$Phos_max))

# predict lm
prediction_lm1 <- predict.lm(lm1, newdata = new_data, se.fit = TRUE, type = "response")

# combine new data and predictions
bind_model1 <- cbind(new_data, prediction_lm1) |> 
  mutate(category ="color")



# second lm for maximum phosphorus ~ species richness
lm2 <- lm(mean_rdiv ~ Phos_max + sum_species, data = df_lm_excl)

# checking model assumptions
summary(lm2)
shapiro.test(resid(lm2))
lmtest::bptest(lm2)
plot(lm2)

# new data
new_data2 <- tibble(Phos_max = seq(from = min(df_lm_excl$Phos_max), to = max(df_lm_excl$Phos_max),length = 50), sum_species = mean(df_lm_excl$sum_species))

# predict model
prediction_lm2 <- predict.lm(lm2, newdata = new_data2, se.fit = TRUE, type = "response")

# combine new data and predictions
bind_model2 <- cbind(new_data2, prediction_lm2) |> 
  mutate(category ="color")

# Plot Fig. 3
mycolor <- c("color" = "#A0E66A")

lm1_plot <- bind_model1 |> 
  ggplot(aes(sum_species, fit,  color = category, fill = category)) +
  geom_line(linewidth = 1.2) +
  geom_ribbon(aes(ymin = (fit - se.fit), ymax = (fit + se.fit)),  alpha = 0.3, color = NA) +
  theme_classic(base_size = 20) +
  ylab("Mean dissimilarity") +
  xlab("Species richness") +
  ylim(1,3) +
  scale_fill_manual(values = mycolor, aesthetics = c("color", "fill"), guide = NULL)

lm2_plot <- bind_model2 |> 
  ggplot(aes(Phos_max, fit, color = category, fill = category)) +
  geom_line(linewidth = 1.2) +
  geom_ribbon(aes(ymin = (fit - se.fit), ymax = (fit + se.fit)),  alpha = 0.3, color = NA) +
  theme_classic(base_size = 20) +
  ylab("Mean dissimilarity") +
  xlab("Maximum total phosphorus (Âµg/L)") +
  ylim(1,3) +
  scale_fill_manual(values = mycolor, aesthetics = c("color", "fill"), guide = NULL)

# combine both plots
figure_3 <- ggarrange(lm1_plot, lm2_plot)

# save as TIFF
# tiff(paste("total_models/plots/lm_species_richness_eutroph.tiff", sep = ""), units="in", width=12, height=5, res=300)
# 
# plot(figure_3)
# 
# # Closing the graphical device
# dev.off()

```
###Community subgroups
####Fig. 4a
We fitted simple linear models for the number of species in each category and the mean dissimilarity in each lake. 
```{r}
# Lms for all categories: endemic, translcated, non_native and non_endemic_native
# with data on all lakes
# Endemic
lm_endemic <- lm(mean_rdiv ~ endemic, data = df_lm)

# checking model assumptions
summary(lm_endemic)
shapiro.test(resid(lm_endemic))
lmtest::bptest(lm_endemic)
plot(lm_endemic)

new_data_a <- tibble(endemic = seq(from = min(df_lm$endemic), to = max(df_lm$endemic),
                                     length = 15))


prediction_endemic <- predict.lm(lm_endemic, newdata = new_data_a, se.fit = TRUE, type = "response")


df_lm_endemic <- cbind(new_data_a, prediction_endemic) |> 
  mutate(category = factor("endemic")) |> 
  rename(species_richness = endemic)

# Non-native

lm_nn <- lm(mean_rdiv ~ non_native, data = df_lm)

# checking model assumptions
summary(lm_nn)
shapiro.test(resid(lm_nn))
lmtest::bptest(lm_nn)
plot(lm_nn)

new_data_b <- tibble(non_native = seq(from = min(df_lm$non_native), to = max(df_lm$non_native),
                                   length = 15))

prediction_nn <- predict.lm(lm_nn, newdata = new_data_b, se.fit = TRUE, type = "response")

df_lm_nn <- cbind(new_data_b, prediction_nn)  |> 
  mutate(category = factor("non_native")) |> 
  rename(species_richness = non_native)

# Non-endemic native

lm_nne <- lm(mean_rdiv ~ native, data = df_lm)

# checking model assumptions
summary(lm_nne)
shapiro.test(resid(lm_nne))
lmtest::bptest(lm_nne)
plot(lm_nne)


new_data_c <- tibble(native = seq(from = min(df_lm$native), to = max(df_lm$native),
                                      length = 15))

prediction_nne <- predict.lm(lm_nne, newdata = new_data_c, se.fit = TRUE, type = "response")

df_lm_nne <- cbind(new_data_c, prediction_nne)  |> 
  mutate(category = factor("non_endemic_native")) |> 
  rename(species_richness = native)


# Translocated (non-native to region) species

lm_trans <- lm(mean_rdiv ~ non_native_region, data = df_lm)

# checking model assumptions
summary(lm_trans)
shapiro.test(resid(lm_trans))
lmtest::bptest(lm_trans)
plot(lm_trans)


new_data_d <- tibble(non_native_region = seq(from = min(df_lm$non_native_region), to = max(df_lm$non_native_region),
                                              length = 15))

prediction_trans <- predict.lm(lm_trans, newdata = new_data_d, se.fit = TRUE, type = "response")

df_lm_trans <- cbind(new_data_d, prediction_trans)  |> 
  mutate(category = factor("translocated")) |> 
  rename(species_richness = non_native_region)


# Combine all four lm predictions
df_all_lms <- rbind(df_lm_endemic, df_lm_nn, df_lm_nne, df_lm_trans)


mycolors <-  c("endemic"= "#63D8F2", "non_endemic_native"="#F26379", "non_native" = "#5A64D8",
               "translocated" = "#F2AD63")



plot_all_lms <- df_all_lms|> 
  ggplot(aes(species_richness, fit, color = category, fill = category)) +
  geom_line(linewidth = 1) +
  geom_ribbon(aes(ymin = (fit - se.fit), ymax = (fit + se.fit)), color = NA, alpha = 0.3) +
  theme_classic(base_size = 16) +
  ylab("Mean dissimilarity") +
  xlab("Species richness") +
  scale_fill_manual(values = mycolors,
                    aesthetics = c("color", "fill"), 
                    labels = c("endemic", "non-native", "non-endemic native", "translocated"),
                    name = NULL)
plot_all_lms
# save as TIFF
# tiff(paste("total_models/plots/lm_all.tiff", sep = ""), units="in", width=11, height=7, res=300)
# # plot(ggarrange(depth1, depth2, ncol = 2))
# # plot science discussion
# plot(plot_all_lms)
# 
# dev.off()
```

#### Fig. 4b 
Predictions of all species shown inside the categories. 
```{r, fig.show='hide'}

# Plot species predictions inside categories across all lakes
# 5 categories;
# endemic: geographically constrained range
# non-native: from NA or Asia 
# non-endemic native: native to Switzerland but not endemic
# non-native region: native to Switzerland and surroundings but has been translocated
# to other Swiss lakes where the species was not native
# endemic translocated: endemic species that were translocated to other lakes

# read in table with the categories and rename the categories
species_category <- read_excel("species_category_across_lakes.xlsx") |> 
  select(-notes) |> 
  mutate(category = ifelse(category == "native", "non_endemic_native", category)) |> 
  mutate(category = ifelse(category == "non_native_region", "non_endemic_native_and_translocated", category)) |> 
  mutate(category2 = factor("all"))

species_category$category <- as.factor(species_category$category)
levels(species_category$category)

# merge predictions with categories
model_pred_categories <- merge(model_predictions, species_category) 

# change category names for facet_wrap
category_names <- c(
  `endemic` = "endemic",
  `endemic_and_translocated` = "translocated endemic",
  `non_endemic_native` = "non-endemic native",
  `non_endemic_native_and_translocated` = "translocated non-endemic native",
  `non_native` = "non-native"
)

# colors for the plot
mycolors1 <-  c("endemic"= "#63D8F2", "non_endemic_native"="#F26379", "non_native" = "#5A64D8",
                "endemic_and_translocated" = "#F2AD63", "non_endemic_native_and_translocated" = "#F2AD63")

# Rescale the predictions to 0-1 
model_pred_categories_rescaled <- model_pred_categories |> 
  group_by(species) |> 
  mutate(fit_rescaled = (fit - min(fit)) / (max(fit) - min(fit)))

# Plot the rescaled predictions
plot_pred <- model_pred_categories_rescaled |>
  # exclude Lepomis gibbosus
  filter(species != "Lepomis_gibbosus") |> 
  ggplot(aes(temp, fit_rescaled, group = species, color = category)) +
  geom_line(linewidth = 0.8) +
  theme_bw(base_size = 16) +
  ylab("Abundance") +
  xlab("Temperature") +
  scale_color_manual(values = mycolors1, guide = NULL) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        legend.position = "bottom",
        legend.title = element_blank()) 

plot_category_predictions <- plot_pred + facet_grid(~category, labeller = as_labeller(category_names))

plot_category_predictions

# save plot as TIFF
# tiff(paste("total_models/plots/plot_category_predictions.tiff", sep = ""), units="in", width=15, height=4, res=300)
# 
# plot(plot_category_predictions)
# 
# dev.off()

```

